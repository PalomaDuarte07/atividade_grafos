# -*- coding: utf-8 -*-
"""grafo_lista_adjacencia.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17cxL0pZzxncA4Hh_hQ2e6_Rl3JoKNWmI
"""

class GrafoListaAdjacencia:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.lista_adjacencia = [[] for _ in range(num_vertices)]

    def adicionar_aresta(self, origem, destino):
        if 0 <= origem < self.num_vertices and 0 <= destino < self.num_vertices:
            self.lista_adjacencia[origem].append(destino)
            # Se o grafo for não direcionado, descomente a linha abaixo
            # self.lista_adjacencia[destino].append(origem)

    def mostrar_lista_adjacencia(self):
        for vertice, vizinhos in enumerate(self.lista_adjacencia):
            print(f"Vértice {vertice} -> {', '.join(map(str, vizinhos))}")

#leitura e carregamento de arquivos

    def carregar_de_arquivo(self, arquivo):
        with open(arquivo, 'r') as file:
            for linha in file:
                origem, destino = map(int, linha.strip().split())
                self.adicionar_aresta(origem, destino)

#busca em largura (BFS)

    def bfs(self, s, t):
        visitado = [False] * self.num_vertices
        fila = deque()
        caminho = [-1] * self.num_vertices

        fila.append(s)
        visitado[s] = True

        while fila:
            atual = fila.popleft()

            if atual == t:
                break

            for vizinho in self.lista_adjacencia[atual]:
                if not visitado[vizinho]:
                    fila.append(vizinho)
                    visitado[vizinho] = True
                    caminho[vizinho] = atual

        if not visitado[t]:
            print("Não há caminho entre os vértices.")
        else:
            print("Caminho entre os vértices:")
            path = []
            while t != -1:
                path.append(t)
                t = caminho[t]
            path.reverse()
            print(" -> ".join(map(str, path)))

#busca por profundidade (DFS)

            def dfs_sem_recursao(self, s, t):
        visitado = [False] * self.num_vertices
        pilha = []
        caminho = [-1] * self.num_vertices

        pilha.append(s)
        visitado[s] = True

        while pilha:
            atual = pilha.pop()

            if atual == t:
                break

            for vizinho in self.lista_adjacencia[atual]:
                if not visitado[vizinho]:
                    pilha.append(vizinho)
                    visitado[vizinho] = True
                    caminho[vizinho] = atual

        if not visitado[t]:
            print("Não há caminho entre os vértices.")
        else:
            print("Caminho entre os vértices:")
            path = []
            while t != -1:
                path.append(t)
                t = caminho[t]
            path.reverse()
            print(" -> ".join(map(str, path)))