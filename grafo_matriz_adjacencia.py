# -*- coding: utf-8 -*-
"""grafo_matriz_adjacencia.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HpiUS1B3I-HlctxndN09VDLITd5uxqTc
"""

class GrafoMatrizAdjacencia:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.matriz_adjacencia = [[0] * num_vertices for _ in range(num_vertices)]

    def adicionar_aresta(self, origem, destino):
        if 0 <= origem < self.num_vertices and 0 <= destino < self.num_vertices:
            self.matriz_adjacencia[origem][destino] = 1
            # Se o grafo for não direcionado, descomente a linha abaixo
            # self.matriz_adjacencia[destino][origem] = 1

    def mostrar_matriz_adjacencia(self):
        for linha in self.matriz_adjacencia:
            print(linha)

    def carregar_de_arquivo(self, arquivo):
        with open(arquivo, 'r') as file:
            for linha in file:
                origem, destino = map(int, linha.strip().split())
                self.adicionar_aresta(origem, destino)

#carregar e ler arquivos
    def carregar_de_arquivo(self, arquivo):
        with open(arquivo, 'r') as file:
            for linha in file:
                origem, destino = map(int, linha.strip().split())
                self.adicionar_aresta(origem, destino)

#busca em largura (BFS)
from collections import deque

class GrafoMatrizAdjacencia:

    def bfs(self, s, t):
        visitado = [False] * self.num_vertices
        fila = deque()
        caminho = [-1] * self.num_vertices

        fila.append(s)
        visitado[s] = True

        while fila:
            atual = fila.popleft()

            if atual == t:
                break

            for vizinho, aresta in enumerate(self.matriz_adjacencia[atual]):
                if aresta == 1 and not visitado[vizinho]:
                    fila.append(vizinho)
                    visitado[vizinho] = True
                    caminho[vizinho] = atual

        if not visitado[t]:
            print("Não há caminho entre os vértices.")
        else:
            print("Caminho entre os vértices:")
            path = []
            while t != -1:
                path.append(t)
                t = caminho[t]
            path.reverse()
            print(" -> ".join(map(str, path)))

#busca em profundidade (DFS) usando pilha para eliminar a recursão

    def dfs_sem_recursao(self, s, t):
        visitado = [False] * self.num_vertices
        pilha = []
        caminho = [-1] * self.num_vertices

        pilha.append(s)
        visitado[s] = True

        while pilha:
            atual = pilha.pop()

            if atual == t:
                break

            for vizinho, aresta in enumerate(self.matriz_adjacencia[atual]):
                if aresta == 1 and not visitado[vizinho]:
                    pilha.append(vizinho)
                    visitado[vizinho] = True
                    caminho[vizinho] = atual

        if not visitado[t]:
            print("Não há caminho entre os vértices.")
        else:
            print("Caminho entre os vértices:")
            path = []
            while t != -1:
                path.append(t)
                t = caminho[t]
            path.reverse()
            print(" -> ".join(map(str, path)))